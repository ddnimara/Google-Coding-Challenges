from math import factorial
from math import gcd
from collections import Counter
def partition(n,start=1):
    """ Recursive partition algorithm which returns the distinct number of ways
        to write n as the sum of natural numbers."""

    # Use yield (generator) for memory efficiency.
    yield [n]
    # Recursion Idea: For every n, we can write it n = a + k, a <= k a>=0.
    # For a = 0, k = n, a simple 'edge case' (yield [n])
    # For a > 0 => k < n, => we can use recursion!
    # We must be wary though to not double count. For instance 5 = 2 + 3 = 3 + 2.
    # For this reason, we can enforce that our partition p is in ascending (not necessarily strictly increasing),
    # that is, p = [p1,p2,...,pm], p1 <= p2 <= ... <= pm.
    # We thus force the recursion for k = n - a to start its partition from 'a'.
    for a in range(start, int(n/2) + 1):
        for p in partition(n-a, a):  # k = n-j
            yield [a]+p

print(list(partition(10)))

def equivalentPartitions(cycle):
    """ Given a partition (which corresponds to specific cycle permutations), finds the number of permutations
        which this partition corresponds to."""
    # Compute permutation group order (n)
    n = sum(cycle)

    # Keep track how many cycles of length 'k' we have
    counterDictionary = Counter(cycle)

    # Compute n choose (k_1, k_2,...,k_l) = n!/(k_1! * k_2! * ... * k_l!)
    partitions = factorial(n)

    for cycleLength in cycle:
        partitions //= factorial(cycleLength)

    # if k_i = k_j, then we do not wish to distinguish between them.
    # For instance, if n = 4 and we have two cycles of length 2, then
    # [a,a,b,b] is the same as [b,b,a,a] (we do not distinguish between those two cycle partitions)
    for cyclesOfSameLength in counterDictionary.values():
        partitions //= factorial(cyclesOfSameLength)

    # For every cycle of length 'k', we have (k-1)! permutations (different cycles).
    # Example: for n = 3 we have (123) != (132) -> 2 distinct 3-cycles.
    for i in cycle:
        partitions *= factorial(i-1)
    return partitions

def solution(w,h,s):
    """ Solution to star System problem. It is based on a generalisation of Burnside's lemma, called
        Polya Enumaration theorem (we use the 'simple' unweighted version). Using this theorem,
        we are capable of enumerating the distinct elements of set
        X = {wxh matrices containing 's' elements per cell} under the action of group G = S_w x S_h."""

    # Burnside's Lemma (gist): Independent star systems = Orbits = 1/|G| * sum_{g \in G} |X_g|,
    # X_g = { elements in X that remain unaltered by the action of g} (permuting rows and columns).
    # Polya enumeration rewrites the above expression for when we want to color the elements in X
    # with 'm' colours, when applying a subgroup G <= S_l, for some l (G is a permutation subgroup)
    # stating that: Orbits = 1/|G| * sum_{g \in G} m**c(g), where c(g) is the number of disjoint cycles
    # that characterise (uniquely) the permutation 'g'.
    # In our problem, m = s, G = S_w x S_h and we thus only need to find the sum in the above expression,
    # by computing c(g) for every g, and grouping up those that exhibit the same c(g).
    x_g = 0
    g_cardinality = factorial(w)*factorial(h)

    # Every permutation 'g' in G can be seen as a permutation in S_w followed by one in S_h.
    # We characterise each 'g' by its cycles, which are in essence a partition of 'w' and 'h'
    # respectively. Cycles with partition 'w' and 'h' the same way (albeit change their elements differently)
    # yield the same c(g) -> group them together.
    for pw in partition(w):
        for ph in partition(h):
            # m = # of permutations 'g' that correspond to this specific partitioning
            m = equivalentPartitions(pw) * equivalentPartitions(ph)

            # Every number 'i' in pw and 'j' in ph refer to the length of a specific cycle.
            # One can show that the number of distinct cycles generated by these two 'i' and 'j'
            # cycles is equal to the gcd of them.

            # Let's try and explain this intuitively with an example:
            # Say i = 4 and j = 2 and let us examine elements that are located in one of these
            # 4 rows and 2 columns. Let us follow a chain that starts from the first column and more specifically
            # x11: x11->x22->x31->x22->x11. Notice how we return to column 1 every 'j' elements. If gcd(i,j)=1 ->
            # we will explore the whole column -> 1 cycle. More generally, one can show that for gcd(i,j)=k, we
            # generate 'k' distinct cycles.
            gcdList = [[gcd(i, j) for i in pw] for j in ph]

            # c(g) = # of cycles => add all the gcd(i,j) for every (i,j)
            exponent = 0
            for l in gcdList:
                exponent += sum(l)
            x_g += m*s**exponent
    return str(int(x_g/g_cardinality))
